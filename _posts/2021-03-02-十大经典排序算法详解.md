---
layout:     post
title:      十大经典排序算法详解
subtitle:   "搞定机试算法题"
date:       2021-03-02
author:     汤泡饭
header-img: img/home-bg-art.jpg
music-id: 1819857342
catalog: true
tags:
    - C++
---

>排序算法是每个程序猿必须掌握的基础算法类别，不管是在研究生复试、机试、大厂面试还是各类算法竞赛中，均会涉及到一定数量的排序算法。因此，掌握基础的十大经典排序算法是解决排序类问题的基础。在实际生产中，最好的排序算法一定要考虑数据集本身的特点（大小、类型、是否已经基本有序等等）来选择，不要拘泥于算法本身。下面将对十大经典排序算法进行详解。

 *参考资料*
* 1、[*计算机考研复试上机指导全书（孙肇博，张飞飞）*](http://product.dangdang.com/23411346.html)
* 2、[十大经典排序算法（动图演示）](https://www.cnblogs.com/onepixel/articles/7674659.html)
* 3、[超详细十大经典排序算法总结（java代码）c或者cpp的也可以明白](https://blog.csdn.net/weixin_41190227/article/details/86600821)

## 0、算法概述
### 0.1 算法分类
常见排序算法可以分为以下两类：
* **比较类排序**：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破`O(nlogn)`，因此也称为**非线性时间比较类排序**。比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。
* **非比较类排序**：不通过比较来决定元素间的相对次序，而是通过确定每个元素之前应该有多少个元素来排序。它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为**线性时间非比较类排序**。 非比较排序时间复杂度低，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。

十大经典排序算法根据以上标准分类如下图所示：
![6P89Q1.md.png](https://s3.ax1x.com/2021/03/01/6P8Kyt.png)

### 0.2 术语解释
* **稳定**：两个数值相同的数据，在排序前后两者的相对位置一致。
* **不稳定**：两个数值相同的数据，在排序前后两者的相对位置相反。
* **内排序**：所有排序操作都在内存中完成。
* **外排序**：由于数据量太大，因此把数据放在磁盘中，排序需要通过磁盘和内存的数据传输才能进行。
* **时间复杂度**：描述算法运行时间的函数，用大`O`符号描述。
* **空间复杂度**：描述算法所需要的内存空间大小。

## 1、冒泡排序（Bubble Sort）

冒泡排序是一种简单的交换排序算法。它重复地从头走访要排序的数列，一次**比较**两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行，直到没有元素再需要交换，则该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢像气泡一样“浮”到数列的顶端，称之为**冒泡排序**or**起泡排序**。冒泡排序是一种**稳定**的排序算法。

### 1.1、算法描述
* 比较相邻的元素。如果第一个比第二个大（or 小），就交换它们两个；
* 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
* 针对所有的元素重复以上的步骤，除了最后一个；
* 重复步骤1~3，直到排序完成。

### 1.2 动画演示
![](https://temp-1301794075.cos.ap-chengdu.myqcloud.com/bubble.gif)

### 1.3 代码实现

```cpp
void Bubble_Sort_old(int *Arr, int len)
{
    for(int i = 0; i < len - 1; i++)
    {
        for(int j = 0; j < len - i - 1; j++)
        {
            if(Arr[j] > Arr[j+1])
                swap(Arr[j], Arr[j+1]);  
                //swap函数包含在头文件<algorithm>中，下同
        }
        for(int k = 0; k < len; k++)
            cout << Arr[k] << " ";
        cout << endl;
    }
}
```

### 1.4 算法分析

* 最佳情况：`O(n^2)`（即使本身已经有序，还是要完成整个排序扫描，则时间花销为`[n(n-1)]/2`）
* 最差情况：`O(n^2)`（本身为倒序，则时间花销为`[3n(n-1)]/2`）
* 平均情况：`O(n^2)`

### 1.5 算法优化

如对数列`{88,1,59,105,9,2,8,15,6,10}`采用传统法排序，每趟输出如下：

```
1 59 88 9 2 8 15 6 10 105 
1 59 9 2 8 15 6 10 88 105 
1 9 2 8 15 6 10 59 88 105 
1 2 8 9 6 10 15 59 88 105 
1 2 8 6 9 10 15 59 88 105 
1 2 6 8 9 10 15 59 88 105 (已有序)
1 2 6 8 9 10 15 59 88 105 
1 2 6 8 9 10 15 59 88 105 
1 2 6 8 9 10 15 59 88 105 
```

发现在第6趟外循环结束后，数列**已经有序**，此时即可结束循环。实现优化方法如下：


**法1**：优化**外层**循环：若在某一趟排序中未发现交换，则说明待排序的无序区中已经有序，因此排序过程可在此趟排序后终止。即设置标志位flag，提前终止排序。
```cpp
void Bubble_Sort_new(int *Arr, int len)
{
    bool flag = true;
    for(int i = 0; i < len - 1 && flag != false; i++)
    {
        flag = false;
        for(int j = 0; j < len - i - 1; j++)
        {
            if(Arr[j] > Arr[j+1])
            {
                flag = true;    //产生了交换，设置flag
                swap(Arr[j], Arr[j+1]);
            }
        }
        if(flag != false)
        {
            for(int k = 0; k < len; k++)
                cout << Arr[k] << " ";
            cout << endl;
        }
    }
}
```

经过优化后的最好情况下的时间复杂度降低到 **`O(n)`**。

**法2**：优化**内层**循环：在每趟扫描中，记住最后一次交换发生的位置`lastExchange`（该位置之后的相邻记录均已有序）。下一趟排序开始时，`R[1 ... lastExchange-1]`是无序区，`R[lastExchange ... n]`是有序区。这样，一趟排序可能使当前无序区扩充多个记录，因此记住最后一次交换发生的位置`lastExchange`，从而减少排序的趟数。

```cpp
void Bubble_Sort_new2(int *Arr, int len)
{
    bool flag = true;
    int k = len - 1;
    int lastExchange = 0;
    for(int i = 0; i < len - 1 && flag != false; i++)
    {
        flag = false;
        for(int j = 0; j < k; j++)
        {
            if(Arr[j] > Arr[j+1])
            {
                flag = true;    //产生了交换，设置flag
                lastExchange = j;   //产生了交换，记录交换位置
                swap(Arr[j], Arr[j+1]);
            }
        }
        k = lastExchange;
        if(flag != false)
        {
            for(int k = 0; k < len; k++)
                cout << Arr[k] << " ";
            cout << endl;
        }
    }
}
```

经过优化后，数列`{88,1,59,105,9,2,8,15,6,10}`的排序过程输出为：
```
1 59 88 9 2 8 15 6 10 105 
1 59 9 2 8 15 6 10 88 105 
1 9 2 8 15 6 10 59 88 105 
1 2 8 9 6 10 15 59 88 105 
1 2 8 6 9 10 15 59 88 105 
1 2 6 8 9 10 15 59 88 105（已有序）
```
可以看出一旦数列排序完成，则立即退出循环，完成排序。

## 2、快速排序（Quick Sort）

通过一趟排序，将待排记录分隔成独立的两个子序列，一个子序列均比基准小，另一个子序列均比基准大，则可分别对这两部分记录继续进行排序，以达到整个序列有序。快速排序是一种**不稳定**的排序算法。

### 2.1 算法描述
快速排序使用**分治法**来把一个序列（list）分为两个子序列（sub-list）。

>**分治**，字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。在计算机科学中，分治法就是运用分治思想的一种很重要的算法。分治法是很多高效算法的基础，如排序算法（快速排序，归并排序），傅立叶变换（快速傅立叶变换）等等。

具体算法描述如下：
* 从数列中挑出一个元素，称为“**基准**”（pivot）；
* 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这一趟操作完成之后，该基准就将原数列划分为两个子序列。这个称为**分区**（partition）操作；
* **递归**地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

### 2.2 动画演示
![](https://temp-1301794075.cos.ap-chengdu.myqcloud.com/quick.gif)

### 2.3 代码实现
```cpp
void Quick_Sort(int *Arr, int low, int high)
{
    int i, j;
    i = low;
    j = high;
    int temp = Arr[low];    //基准值
    while(i < j)
    {
        while(i < j && Arr[j] > temp)
            j--;
        if(i < j)   //当前j指向比基准小的值
        {
            Arr[i] = Arr[j];    //放到小于基准的部分
            i++;
        }
        while(i < j && Arr[i] < temp)
            i++;
        if(i < j)   //当前i指向比基准大的值
        {
            Arr[j] = Arr[i];    //放回大于基准的那个值的位置
            j--;
        }
    }
    Arr[i] = temp;  //此时i、j重合，将基准值放到此处
    
    //递归
    if(low < i)
        Quick_Sort(Arr, low, j-1);
    if(i < high)
        Quick_Sort(Arr, j+1, high);
}
```
### 2.4 算法分析
* 最佳情况：`O(nlog2n)`（快速排序的一次划分算法从两头交替搜索，直到low和hight重合，因此其时间复杂度是`O(n)`；而整个快速排序算法的时间复杂度与**划分的趟数**有关。理想的情况是，每次划分所选择的中间数恰好将当前序列几乎**等分**，经过`log2n`趟划分，便可得到长度为1的子表。）
* 最差情况：`O(n^2)`（最坏的情况是，每次所选的中间数是当前序列中的**最大或最小**元素，这使得每次划分所得的子表中一个为空表，另一子表的长度为原表的长度-1。这样，长度为`n`的数据表的快速排序需要经过`n`趟划分）
* 平均情况：`O(nlog2n)`(该排序方法被认为是**目前最好的一种内部排序方法**)

### 2.5 算法优化
优化快速排序算法的关键点在于找到**恰当的基准值**。最坏情况下找到的基准值刚好是当前数列的**最大or最小**值，则快速排序退化为冒泡排序；最佳情况下找到的基准值刚好可以将待排序数列划分为**等长**的子数列。

**法1：三数取中（median-of-three**）。最佳状态划分其基准值是数列排序后的中间的值，也就是第N/2个数。可是这很难算出来，并且会明显减慢快速排序的速度。这样的中值的估计可以通过随机选取三个元素并用它们的中值作为基准值而得到。事实上，随机性并没有多大的帮助，因此一般的做法是**使用左端、右端和中心位置上的三个元素的中值作为基准值**。显然使用三数中值分割法消除了预排序输入的不好情形，并且减少快排大约14%的比较次数。
```cpp
int SelectPivotMedianOfThree(int *Arr,int low,int high) {
    int mid = low + ((high - low) >> 1);//计算数组中间的元素的下标

    if (Arr[mid] > Arr[high])
        swap(Arr[mid], Arr[high]);
    if (Arr[low] > Arr[high])
        swap(Arr[low], Arr[high]);
    if (Arr[mid] > Arr[low])
        swap(Arr[mid], Arr[low]);

    return Arr[low]; //low的位置上保存这三个位置中间的值
}
```
**法2**：聚集相等元素。在划分过程中以后，将数列中相同值的元素放到**数列的两端**；在划分结束后将相同值的元素放到**基准值周围**。举例：

待排序序列：`1 4 6 7` 6 `6 7 6 8 6`（pivot为6）
与Arr[low]交换：6 `4 6 7 1 6 7 6 8 6`
本次划分后，未优化的结果：`1 4 6` 6 `7 6 7 6 8 6`
则下一次划分的子序列分别是：`1 4 6`和`7 6 7 6 8 6`
本次划分后，优化的结果：`1 4` 6 6 6 6 6 `7 8 7`
则下一次划分的子序列分别是：`1 4`和`7 8 7`。

```cpp
void gather(int *Arr, int low, int high, int boundKey, int *left, int *right)
{
    if (low < high)
    {
        int count = boundKey - 1;
        for (int i = boundKey - 1; i >= low; --i)
        {
            if (Arr[i] == Arr[boundKey])
            {
                swap(Arr, i, count);
                count--;
            }
        }
        *left = count;
        count = boundKey + 1;
        for (int i = boundKey + 1; i <= high; ++i)
        {
            if (Arr[i] == Arr[boundKey])
            {
                swap(Arr, i, count);
                count++;
            }
        }
        *right = count;
    }
}
```
**优化结果**（参考）：
![](https://temp-1301794075.cos.ap-chengdu.myqcloud.com/table.png)

可以看出，优化方法1主要解决**已有序数列**的排序问题，优化方法2主要解决**重复值数列**的排序问题。

## 3、简单插入排序（Insertion Sort）
插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。快速排序是一种**稳定**的排序算法。

### 3.1 算法描述

一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：
* 从第一个元素开始，该元素可以认为已经被排序；
* 取出下一个元素，在已经排序的元素序列中**从后向前**扫描；
* 如果该元素（已排序）大于新元素，将该元素移到下一位置；
* 重复步骤3，直到找到已排序的元素**小于或者等于新元素**的位置；
* 将新元素插入到该位置后；
* 重复步骤2~5。

### 3.2 动画演示
![](https://temp-1301794075.cos.ap-chengdu.myqcloud.com/quick.gif)

### 3.3 代码实现

```cpp
void Insertion_Sort(int *Arr, int len)
{
    int temp;
    for(int i = 1; i < len; i++)    //从第2个开始
    {
        temp = Arr[i];
        int j = i;
        while(j && Arr[j-1] > temp)
        {
            Arr[j] = Arr[j-1];
            j--;
        }
        Arr[j] = temp;
        for(int k = 0; k < len; k++)
            cout << Arr[k] << " ";
        cout << endl;
    }
}
```

### 3.4 算法分析
* 最佳情况：`O(n)`（当待排序数组是**有序**时是最优的情况，只需当前数跟前一个数比较一次就可以了，这时一共需要比较`n-1`次）
* 最差情况：`O(n^2)`（待排序数组是**逆序**的，此时需要比较次数最多，总次数为`[n(n-1)]/2`)
* 平均情况：`O(n^2)`)

### 3.5 算法优化
**法1**：影响简单插入排序算法效率的关键在于：挨个比较并寻找插入的位置。不妨使用二分查找算法直接找出待插入位置。
```cpp
void Insertion_Sort_new(int *Arr, int len)
{
    for(int idx = 1; idx <= len -1; idx++)
    {
        if(Arr[idx] < Arr[idx -1])
        {
            int left = 0;
            int right = idx -1;
            int end = Arr[idx];
            
            while(left <= right)    //二分查找
            {
                int mid = left + ((right - left) >> 1);
                // (right - left) >> 1代替除以2，运算速度更快
                // mid = left + (right + left) / 2防止溢出
                if(end < Arr[mid])
                    right = mid - 1;
                else
                    left = mid + 1;
            }

            for(int j = idx; j > 0 && j > right + 1; j--)
            {
                Arr[j] = Arr[j-1];
            }
            Arr[right+1] = end;
        }
    }
}
```

**法2**：希尔排序（继续看）。

## 4、希尔排序（Shell Sort）
1959年由Shell发明，第一个突破 **`O(n)`** 的排序算法。在插入排序中，如果待排序列中的某个元素，距离有序数列中待插入位置非常远，就需要比较很多次才可以到达插入位置，这是因为待插入元素局部非常无序，比如说`[2,3,4,5,6,7,8,1...]`，我们要插入1，就必须将1和前面的2~8**每个值都比较一下**，就是因为1附近非常无序。想象一下，如果待插入元素附近比较有序，那么在进行插入排序的时候就只需要比较非常少的几次就可以插入到正确位置。希尔排序就是**先把整个序列排得相对比较有序**，再进行插入排序的时候，需要比较的次数就会变得很少。

简单插入排序相当于增量为**1**的希尔排序，希尔排序相当于将这个间隔从最大为数组长度的一半一直降到1，它与简单插入排序的不同之处在于，它会优先比较距离较远的元素。

希尔排序又叫缩小增量排序。希尔排序是一种**不稳定**的排序算法。

### 4.1 算法描述

将整个待排序的记录序列分割成为若干子序列后，分别进行直接插入排序。具体算法描述：
* 选择一个增量序列`t1,t2,...,tk`，其中`ti>tj`，`tk=1`；
* 按增量序列个数`k`，对序列进行`k`趟排序；
* 每趟排序，根据对应的增量`ti`，将待排序列分割成若干长度为`m`的子序列，分别对各子表进行**直接插入排序**。仅增量因子为1时，整个序列作为一个表来处理，表长度即为整个序列的长度。

### 4.2 动画演示
![](https://temp-1301794075.cos.ap-chengdu.myqcloud.com/shell.gif)

### 4.3 代码实现
```cpp
void Shell_Sort(int *Arr, int len, int INCRGAP) //INCRGAP为步长
{
    int insertNum = 0;
    int gap = len / INCRGAP + 1;
    // 步长初始化,注意如果当len < INCRGAP时，gap为0，所以为了保证进入循环，gap至少为1
    while(gap)
    {
        for (int i = gap; i < len; i++) // 分组，在每个子序列中进行插入排序
        {
            insertNum = Arr[i];//将当前的元素值先存起来方便后面插入
            int j = i;
            while (j >= gap && insertNum < Arr[j - gap])//寻找插入位置
            {
                Arr[j] = Arr[j - gap];
                j -= gap;
            }
            Arr[j] = insertNum;
        }
        gap = gap / INCRGAP;
    }
}
```
### 4.4 算法分析
希尔排序的复杂度分析是一个困难的数学问题，与选择的步长有关。程序猿就不讨论这个问题了hhhhh。

**结论**：
* 平均时间复杂度： **`O(n^(1.3~2))`** ；
* 当n较小时，希尔排序和插入排序相差不大，都为 **`O(n^2)`** 左右;
* 当n很大时，时间增长幅度逐渐放缓，平均复杂度大致是 **`n√n`** ，一般记为 **`nlogn`**。

### 4.5 算法优化
使用更高性能的递增序列（略！）

## 5、简单选择排序（Selection Sort）
选择排序是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。简单选择排序是一种**不稳定**的排序算法。（！！！）

### 5.1 算法描述

`n`个记录的选择排序可经过`n-1`趟简单选择排序得到有序结果。具体算法描述如下：

* 初始状态：无序区为`R[1...n]`，有序区为空；
* 第`i`趟排序`(i=1,2,3...n-1)`开始时，当前有序区和无序区分别为`R[1...i-1]`和`R(i...n）`。该趟排序从当前无序区中选出关键字**最小**的记录`R[k]`，将它与无序区的第1个记录`R`**交换**，使`R[1...i]`和`R[i+1...n]`分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；
* `n-1`趟结束，数组有序化了。

### 5.2 动画演示
![](https://temp-1301794075.cos.ap-chengdu.myqcloud.com/selection.gif)

### 5.3 代码实现
```cpp
void Selection_Sort(int *Arr, int len)
{
    int minIndex;
    for(int i = 0; i < len - 1; i++)
    {
        minIndex = i;   //记录最小元素下标
        for(int j = i + 1; j < len; j++)
        {
            if(Arr[minIndex] > Arr[j])
                minIndex = j;
        }
        if(minIndex != i)
            swap(Arr[minIndex], Arr[i]);
        for(int k = 0; k < len; k++)
            cout << Arr[k] << " ";
        cout << endl;
    }
}
```
### 5.4 算法分析
* 最好情况 = 最坏情况 = **`O(n^2)`**；
* 任何情况下都需要遍历数组才能找到峰值元素，所以复杂度**与原始序列是否有序无关**。

### 5.5 算法优化
在每次遍历数组时，同时找出区间中的最大值与最小值。最大值放数组右侧，最小值放数组左侧。
```cpp
void Selection_Sort_new(int *Arr, int len)
{
    for (int i = 0; i < len - 1 - i; i++)
    {
        int min = i;
        int max = len - 1 - i;
        if (Arr[min] > Arr[max])
            swap(Arr[min], Arr[max]);
        for(int j = i + 1; j < len - 1 - i; j++)
            //找区间中的最大与最小
        {
            if (Arr[j] < Arr[min]) min = j;
            if (Arr[j] > Arr[max]) max = j;
        }
        swap(Arr[i], Arr[min]);
        swap(Arr[len - 1 - i], Arr[max]);
        for(int k = 0; k < len; k++)
            cout << Arr[k] << " ";
        cout << endl;
    }
}
```
易得出，优化后的选择排序算法时间复杂度仍是 **`O(n^2)`** 。虽然时间复杂度在优化前后一致，但优化后的算法所需要循环的次数显然下降，排序效率更高。

## 6、堆排序
>堆的定义如下: `n`个元素的序列`{k1,k2,...,kn}`当且仅当满足一下条件时，称之为堆。
![](https://temp-1301794075.cos.ap-chengdu.myqcloud.com/dui)
可以将堆看做是一个**完全二叉树**。并且，每个结点的值都大于等于其左右孩子结点的值，称为**大顶堆**；或者每个结点的值都小于等于其左右孩子结点的值，称为**小顶堆**。

堆排序是利用堆进行排序的方法。其基本思想为：将待排序列构造成一个大顶堆(或小顶堆)，整个序列的最大值(或最小值)就是堆顶的根结点，**将根节点的值和堆数组的末尾元素交换，此时末尾元素就是最大值(或最小值)，然后将剩余的`n-1`个序列重新构造成一个堆**，这样就会得到`n`个元素中的次大值(或次小值)，如此反复执行，最终得到一个有序序列。(如下图所示)
![](https://temp-1301794075.cos.ap-chengdu.myqcloud.com/test.png)
如何将二叉树调整为堆：从二叉树最后一个非叶子结点（**其在数组中的序号(数组从0开始计数)一般为数组的长度除以2减1**)开始，将结点上的值依次和左右子树中的值做比较，若子树上的值大于结点值，则将其交换。对二叉树上所有的非叶子结点执行上述操作，最终将二叉树调整成为了一个大顶堆。

堆排序是一种**不稳定**的排序算法。

### 6.1 算法描述
* 将初始待排序关键字序列`[R1,R2,...,Rn]`构建成大顶堆，此堆为初始的无序区；
* 将堆顶元素`R[1]`与最后一个元素`R[n]`交换，此时得到新的无序区`[R1,R2,...,Rn-1]`和新的有序区`[Rn]`,且满足`R[1,2,...,n-1] <= R[n]`；
* 由于交换后新的堆顶`R[1]`可能违反堆的性质，因此需要对当前无序区`[R1,R2,...,Rn-1]`调整为新堆，然后再次将`R[1]`与无序区最后一个元素交换，得到新的无序区`[R1,R2,...,Rn-2]`和新的有序区`[Rn-1,Rn]`。不断重复此过程直到有序区的元素个数为`n-1`，则整个排序过程完成。

**简单来说**，堆排序就是先构成**完全二叉树**，再循环进行大顶堆调整，交换根元素与末尾元素的过程。
>一棵深度为`k`的有`n`个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为`i（1≤i≤n）`的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。

### 6.2 动画演示
![](https://temp-1301794075.cos.ap-chengdu.myqcloud.com/heap.gif)

### 6.3 代码实现
```cpp
void adjust(int *Arr, int len, int index)
{
    int left = 2 * index + 1; // index的左子节点
    int right = 2 * index + 2;// index的右子节点
    int maxIdx = index;

    if(left < len && Arr[left] > Arr[maxIdx])
        maxIdx = left;
    if(right < len && Arr[right] > Arr[maxIdx])
        maxIdx = right;
    if(maxIdx != index)
    {
        swap(Arr[maxIdx], Arr[index]);
        adjust(Arr, len, maxIdx);
    }
}

void Heap_Sort(int *Arr, int len)
{
    //构建大顶堆（从二叉树最后一个非叶子结点开始）
    for(int i = len / 2 - 1; i >= 0; i--)
        adjust(Arr, len, i);

    //调整大顶堆
    for(int i = len - 1; i >= 1; i--)
    {
        swap(Arr[0], Arr[i]); 
        adjust(Arr, i, 0); 
    }
}
```
### 6.4 算法分析
* **初始化堆时**：时间复杂度为 **`O(n)`**；
* **调整堆时**：时间复杂度为 **`O(nlogn)`**；
* **总时间复杂度**：**`O(nlogn)`**；
> 推导过程参考：https://www.cnblogs.com/lylhome/p/13276081.html

### 6.5 算法优化
堆中从根节点到叶节点的一条路径是有序的，大顶堆是降序，我们在调整堆操作时，实际上是在找根节点在某条路径上的一个插入位置。可以使用**二分查找**的思想，一次性下降到当前高度`h`的一半的位置（在下降的过程中要将沿途的较大的子节点上移，这样在`h/2`高度形成空位），即`h/2`。再比较在一半高度`h/2`的节点与根节点的大小，如果比根节点大则继续寻找当前一半高度位置的元素即`h/4`，依次类推；如果当前高度的元素比根节点小，我们就将根节点再上移。这样堆排序的总体复杂度变为 **`O(n·loglogn)`**。

## 7、归并排序（Merge Sort）
归并排序是建立在**归并操作**上的一种有效的排序算法。该算法是采用**分治法**的一个非常典型的应用。它将**已有序**的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为**2-路归并**。 

和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 **`O(nlogn)`** 的时间复杂度。**代价是需要额外的内存空间**。简单选择排序是一种**稳定**的排序算法。

### 7.1 算法描述
* 把长度为`n`的输入序列分成两个长度为`n/2`的子序列；
* 对这两个子序列分别采用归并排序；
* 将两个排序好的子序列合并成一个最终的排序序列。

### 7.2 动画演示
![](https://temp-1301794075.cos.ap-chengdu.myqcloud.com/merge.gif)

### 7.3 代码实现
```cpp
int arrTemp[100] = {0}; //用于临时保存合并结果

void Merge(int *Arr, int low, int mid, int high)    //合并函数
{
    int i = low;
    int j = mid + 1;
    int k = low;
    while(i <= mid && j <= high)
    {
        if(Arr[i] <= Arr[j])    //稳定排序关键，必须为<=而不是<
            arrTemp[k++] = Arr[i++];
        else
            arrTemp[k++] = Arr[j++];
    }
    //如果前半段没有复制完
    while(i <= mid)
        arrTemp[k++] = Arr[i++];
    //如果后半段没有复制完
    while(j <= high)
        arrTemp[k++] = Arr[j++];
    //将temp写回原数组
    for(i = low; i <= high; i++)
        Arr[i] = arrTemp[i];
}

void MergeSort(int *Arr, int low, int high)
{
    if(low < high)
    {
        int mid = (low + high) / 2;
        MergeSort(Arr, low, mid);
        MergeSort(Arr, mid+1, high);
        Merge(Arr, low, mid, high);
    }
}
```
特别注意在Merger函数中比较条件为`Arr[i] <= Arr[j]`，**此为稳定排序的关键**！！！因为当`Arr[i]`与`Arr[j]`相等时，所执行的操作是把`i`所指向的元素（前一个）复制到临时数组中；若写成了`<`，则所执行所执行的操作是把`j`所指向的元素（后一个）复制到临时数组中，**刚好让相等的两个元素的前后顺序发生了变化，变成了不稳定排序！**

### 7.4 算法分析
归并排序是比较复杂的排序，其**总时间 = 分解时间 + 解决问题时间 + 合并时间**。分解时间就是把一个待排序序列分解成子序列，其时间为一常数，时间复杂度为 **`O(1)`** 。解决问题时间是两个递推式，把一个规模为`n`的问题分成两个规模分别为`n/2`的子问题，时间为 **`2T(n/2)`** 。合并时间复杂度为 **`O(n)`**。因此总时间 **`T(n) = 2T(n/2) + O(n)`** 。这个递归式可以用递归树来解：

![](https://temp-1301794075.cos.ap-chengdu.myqcloud.com/tree.gif)

假设解决最后的子问题用时为常数`c`，则对于`n`个待排序记录来说整个问题的规模为`cn`。从递归树可以看出，第一层时间代价为`cn`，第二层时间代价为`cn/2+cn/2=cn`，以此类推，**每一层时间代价都是`cn`** ，总共有`logn+1`层。所以总的时间代价为`cn·(logn+1)`，即时间复杂度是 **`O(nlogn)`** （最好、最坏、平均）。

### 7.5 算法优化
**法1**：假如在第一次归并后出现如下情况：`[2,4|5,7|1,8|3,6]`，其中`[2,4|5,7]`**已经有序**，不需要再次遍历归并，则可以设置以下判断条件：`Arr[mid] < Arr[mid+1]`，如果条件成立，则证明已经有序，不需要再执行`Merge(Arr, low, mid, high)`。但此种方式对平均时间复杂度优化效果不明显，因为该算法的主要时间耗费**并不是在归并阶段，而是递归分组阶段**。

**法2**：Java中`Arrays.sort()`方法采用了一种名为**TimSort**的排序算法，是一种**起源于归并排序**和插入排序的混合排序算法（工业算法，过程复杂），设计初衷是为了在真实世界中的各种数据中可以有较好的性能。基本工作过程是：
* 扫描数组，确定其中的单调上升段和严格单调下降段，将严格下降段反转；
* 定义最小基本片段长度，短于此的单调片段通过插入排序集中为长于此的段；
* 反复归并一些相邻片段，过程中避免归并长度相差很大的片段，直至整个排序完成，所用分段选择策略可以保证 **`O(nlogn)`** 时间复杂性。

可以看到，原则上TimSort是归并排序，但小片段的合并中用了插入排序。
> TimSort详解：<https://www.infopulse.com/blog/timsort-sorting-algorithm/>

## 8、计数排序（Counting Sort）
计数排序**不是基于比较**的排序算法，其核心在于将输入的数据值转化为**键**存储在额外开辟的数组空间中。作为一种**线性时间复杂度**的排序，计数排序要求输入的数据必须是**有确定范围的整数**。计数排序是一种**稳定**的排序算法。

任何比较排序算法的时间复杂度的上限为 **`O(nlogn)`**, 不存在比 **`O(nlogn)`** 更优的比较排序算法。如果想要在时间复杂度上超过 **`O(nlogn)`** 的时间复杂度，肯定需要加入其它条件。计数排序就加入了限制条件，从而使时间复杂度为O(n)。

计数排序**要求**待排序的`n`个元素的大小在`[0, k]`之间，并且`k`与`n`在一个数量级上，即`k = O(n)`。此时使用计数排序可以把时间复杂度降到 **`O(n)`** 上。

### 8.1 算法描述
* 找出待排序的数组中**最大和最小**的元素；
* 统计数组中每个值为`i`的元素出现的次数，存入数组C的第i项；
* 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；
* **反向填充**目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。

### 8.2 动画演示
![](https://temp-1301794075.cos.ap-chengdu.myqcloud.com/count.gif)

### 8.3 代码实现
```cpp
void CountingSort(int *Arr, int len, int maxNum)
{

    //统计待排序数组中每一个元素的个数
    int* ArrayCount = new int[maxNum + 1]{0};
    for (int i = 0; i < len; i++)
        ++ArrayCount[Arr[i]];

    //此处计算待排序数组中小于等于第i个元素的个数.
    //如果要进行大到小的排序，就计算大于等于第i个元素的个数，也就从后向前进行累加;
    for (int i = 1; i < maxNum + 1; i++)
        ArrayCount[i] += ArrayCount[i-1];

    //生成输出数组（保证排序稳定，从后向前添加元素）
    int* ArrayResult = new int[len];
    for (int i = len - 1; i >= 0; i--)
    {
        int nIndex = ArrayCount[Arr[i]] - 1; //计算某个数在结果数组中的下标
        ArrayResult[nIndex] = Arr[i];
        //有重复的元素，所以要减1，为下一个重复的元素计算正确的下标;
        --ArrayCount[Arr[i]];
    }

    //释放内存空间
    memcpy(Arr, ArrayResult, sizeof(int) * len);
    delete [] ArrayCount;
    ArrayCount = nullptr;
    delete [] ArrayResult;
    ArrayResult = nullptr;
}
```

### 8.4 算法分析
当输入的元素是`n`个`0`到`k`之间的整数时，时间复杂度是 **`O(n+k)`** ，空间复杂度也是 **`O(n+k)`** ，其排序速度**快于任何比较排序算法** (以空间换时间)。当`k`不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。

### 8.5 算法优化
不难发现存在这样一个问题：如果要排序的`20`个随机整数的范围在`81~93`，那么就需要建立一个长度为`94`的数组，这样就会造成新建的数组的前面`81个`空间位置就白白浪费。因此，使用使用数列的**最大值-最小值+1**作为统计数组的长度即可，同时使用最小值作为一个偏移量，用于计算整数在统计数组中的下标。

优化后的代码：
```cpp
void CountingSort(int *Arr, int len, int maxNum)
{

    int min = Arr[0];
    int max = Arr[0];
    for(int i = 0; i < len; i++)
    {
        if(Arr[i] < min) min = Arr[i];
        if(Arr[i] > max) max = Arr[i];
    }
    int d = max - min;
    //统计待排序数组中每一个元素的个数
    int* ArrayCount = new int[d + 1]{0};
    for (int i = 0; i < len; i++)
        ++ArrayCount[Arr[i]];
    //下同，略
}
```
**另一种优化**：请看下一个算法。

## 9、桶排序（Bucket Sort）
桶排序是计数排序的升级版，它利用了函数的映射关系，高效与否的关键就在于这个**映射函数的确定**。桶排序的工作的原理：假设输入数据**服从均匀分布**，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序）。桶排序是一种**稳定**的排序算法。

### 9.1 算法描述
* 人为设置一个BucketSize，作为每个桶所能放置不同数值的个数（例如当`BucketSize == 5`时，该桶可以存放`[1,2,3,4,5]`这几种数字；但是**容量不限**，即可以存放100个3）；
* 遍历输入数据，并且把数据一个一个放到对应的桶里去；
* 对每个**不是空的**桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；
* 从不是空的桶里把排好序的数据拼接起来。 

### 9.2 动画演示
![](https://temp-1301794075.cos.ap-chengdu.myqcloud.com/bucket.gif)

### 9.3 代码实现
```java
public static ArrayList<Integer> BucketSort(ArrayList<Integer> array, int bucketSize) {
        if (array == null || array.size() < 2)
            return array;
        int max = array.get(0), min = array.get(0);
        // 找到最大值最小值
        for (int i = 0; i < array.size(); i++) {
            if (array.get(i) > max)
                max = array.get(i);
            if (array.get(i) < min)
                min = array.get(i);
        }
        int bucketCount = (max - min) / bucketSize + 1;
        ArrayList<ArrayList<Integer>> bucketArr = new ArrayList<>(bucketCount);
        ArrayList<Integer> resultArr = new ArrayList<>();
        //构造桶
        for (int i = 0; i < bucketCount; i++) {
            bucketArr.add(new ArrayList<Integer>());
        }
        //往桶里塞元素
        for (int i = 0; i < array.size(); i++) {
            bucketArr.get((array.get(i) - min) / bucketSize).add(array.get(i));
        }
        for (int i = 0; i < bucketCount; i++) {
            if (bucketSize == 1) { 
                for (int j = 0; j < bucketArr.get(i).size(); j++)
                    resultArr.add(bucketArr.get(i).get(j));
            } else {
                if (bucketCount == 1)
                    bucketSize--;
                ArrayList<Integer> temp = BucketSort(bucketArr.get(i), bucketSize);
                for (int j = 0; j < temp.size(); j++)
                    resultArr.add(temp.get(j));
            }
        }
        return resultArr;
    }
```
桶排序用的地方非常非常少，其可以看作是计数排序的一种优化。以上代码来源于网络，未经测试，仅供思路参考！

### 9.4 算法分析
桶排序最好情况下使用线性时间`O(n)`。桶排序的时间复杂度取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为`O(n)`。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大（**空间换时间**）。 

最佳情况： **`T(n) = O(n+k)`**  ，最差情况： **`T(n) = O(n+k)`** ，平均情况： **`T(n) = O(n^2)`** 。

### 9.5 算法优化
> **参考**：《漫画：什么是桶排序》
> <https://blog.csdn.net/csdnsevenn/article/details/83218431>

## 10、基数排序
基数排序是按照数据低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时某些属性是有**优先级顺序**的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序是一种**稳定**的排序算法。

### 10.1 算法描述
* 找出数组中的最大数，并取得位数；
* arr为原始数组，从最低位开始取每个位组成radix数组；
* 对radix进行计数排序（利用计数排序适用于小范围数的特点）；

### 10.2 动画演示
![](https://temp-1301794075.cos.ap-chengdu.myqcloud.com/radix.gif)

### 10.3 代码实现
```cpp
int maxbit(int *Arr, int len)
{
    int d = 1; //保存最大的位数
    int p = 10;
    for(int i = 0; i < len; ++i)
    {
        while(Arr[i] >= p)
        {
            p *= 10;
            ++d;
        }
    }
    return d;
}

void Radix_Sort(int *Arr, int len) //基数排序
{
    int d = maxbit(Arr, len);
    int tmp[len];
    int count[10]; //计数器
    int i, j, k;
    int radix = 1;
    for(i = 1; i <= d; i++) //进行d次排序
    {
        for(j = 0; j < 10; j++)
            count[j] = 0; //每次分配前清空计数器
        for(j = 0; j < len; j++)
        {
            k = (Arr[j] / radix) % 10; //统计每个桶中的记录数
            count[k]++;
        }
        for(j = 1; j < 10; j++)
            count[j] += count[j - 1]; //将tmp中的位置依次分配给每个桶
        for(j = len - 1; j >= 0; j--) //将所有桶中记录依次收集到tmp中
        {
            k = (Arr[j] / radix) % 10;
            tmp[count[k] - 1] = Arr[j];
            count[k]--;
        }
        for(j = 0; j < len; j++) //将临时数组的内容复制到data中
            Arr[j] = tmp[j];
        radix = radix * 10;
    }
}
```
### 10.4 算法分析
**基数排序性能比桶排序要略差**，每一次关键字的桶分配都需要 **`O(n)`** 的时间复杂度，而且分配之后得到新的关键字序列又需要 **`O(n)`** 的时间复杂度。假如待排数据可以分为`d`个关键字，则基数排序的时间复杂度将是 **`O(d·2n)`** ，当然`d`要远远小于`n`，因此基本上还是**线性级别**的。

基数排序的空间复杂度为 **`O(n+k)`**，其中`k`为桶的数量。一般来说`n>>k`，因此额外空间需要大概`n`个左右。

### 10.5 算法优化
**法1：避免内存分配。** 原始基数排序中桶变量`count`使用`malloc`分配空间，我们首先将该动态内存分配改为**栈上固定内存分配**。可以看出，通过改为固定内存分配，基数排序的性能有小幅提升，但是这还不足以与快速排序相匹配。我们还需要考虑别的优化技巧。

**法2：修改基数。** 通过基数排序的复杂度可以看出，影响复杂度的很大一个参数是**基数的选择**。很多人在使用基数排序时都会默认基数为`10`，但是这样会显著增大算法复杂度的常量，因而在数组长度较大时，**选用较大的基数可能会使性能更好**。我们将算法的基数改为`1000`，可以看出，通过修改基数，基数排序的性能有很大提升，当数组长度大于`10000`时，基数排序的性能已经超过快速排序。

但是这还不足以说明基数排序的优势。按复杂度推算，快速排序的复杂度为`O(n·logn)`，基数排序复杂度在基为`1000`时复杂度为`O(6n+2r)`，因而当元素个数在`500`左右时，两者的性能就应该达到一样，这说明算法还有优化余地。

![](https://temp-1301794075.cos.ap-chengdu.myqcloud.com/comp)

## 11、算法总结
![6P89Q1.md.png](https://s3.ax1x.com/2021/03/01/6PYul9.md.png)
其中：

* **`n`**：数据规模。
* **`k`**：桶的个数。
* **`In-place`**：占用常数内存，不占用额外存储空间。
* **`Out-place`**：除占用常数内存外，还占用额外存储空间。


>啊啊啊啊啊啊啊终于写完了，撒花！